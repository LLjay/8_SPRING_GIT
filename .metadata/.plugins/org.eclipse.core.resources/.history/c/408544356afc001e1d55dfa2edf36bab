package com.kh.spring.member.controller;

import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import com.kh.spring.member.model.vo.Member;
import com.kh.spring.member.service.MemberService;

// Component -> 기본적으로 bean에 등록해주는 어노테이션, 하지만 우리는 컨트롤러를 만들 것
// Component 어노테이션의 성질을 갖고 있으나 이건 여기에 맵핑값이 있다는 뜻을 포함
// 이것도 servlet-context에 bean 등록을 해야 사용 가능
@Controller
public class MemberController {
	
	// 스프링이 의존성을 주입한 것이라고 알아야 하므로 어노테이션 적용
	@Autowired
	private MemberService memberService;
	// 의존성을 주입한 것
	// 생명주기 관리를 해준 것이다, 객체가 생성되고 소멸하는 과정까지 스프링이 다 해줄 것
	// ?????????????????????????
	// 인터페이스니까 변경 되어도 상관 없음?
//	private MemberService memberService = new MemberServiceImpl();
//	원래 이렇게 했음
	/*
	 * #기존 객체 생성 방식
	 * - 객체 간 결합도가 높아짐(소스코드 수정이 일어날 경우 하나하나 전부 다 바꿔줘야 함)
	 *  	// 객체 간 결합도가 낮아야 유지보수가 편함
	 *  	// 포조? 의존성을 주입하면 포조 컨트롤러가 되는 것, 외부의 영향을 덜 받으면서 활용할 수 있는 객체
	 *  - 서비스가 동시에 매우 많은 횟수 요청이 될 경우 그만큼 객체 생성
	 *  	// 컨트롤러 필드에 서비스를 넣을 경우 유저가 관리해야 함
	 *  
	 *  #Spring의 DI(Dependency Injection)를 이용한 방식
	 *  - 객체를 생성해서 주입해줌
	 *  - new라는 객체 생성 키워드 없이 @Autowired라는 어노테이션으로 사용해야 함
	 */
	
	/*
	 * Spring에서 파라미터를 받는 방법
	 * 1. HttpServletRequest 활용해 전달 받기 (jsp/servlet 방식)
	 * 		해당 메소드의 매개변수로 HttpServletRequest 작성해두면
	 * 		스프링 컨테이너가 해당 메소드를 호출 시 자동으로 객체를 생성해 매개변수로 주입해줌
	 */

// 어노테이션으로 bean에 등록 했으니 이제 맵핑 해줄 것
//	@RequestMapping(value="/login.me")
//	원래는 value가 정석이나 이렇게 생략해도 무방, 쓰는 경우는 다른 것과 혼용해서 쓸 때
	/*@RequestMapping("login.me")
	public String loginMember(HttpServletRequest request) {
//		원래 안 사용하는 건데 내가 request 객체가 필요하다고 기술 해주니까 디스패처 서블릿에서 넘겨준 것
		String userId = request.getParameter("userId");
		String userPwd = request.getParameter("userPwd");
		
		System.out.println("userId : " + userId);
		System.out.println("userPwd : " + userPwd);
		
		return "main";
		// == /WEB-INF/views/main.jsp
	}*/
//  return에 넘기는 게 jsp 페이지, 그럼 그 페이지를 자동으로 넘겨줌
//	servlet-context 안에 등록된 접두접미어가 main 앞뒤로 붙어 그 경로의 파일을 리턴 해준 것

	/*
	 * 2. @RequestParam 어노테이션을 이용하는 방법
	 * request.getParameter("키")로 밸류를 추출하는 역할을 대신 해주는 어노테이션
	 * value 속성의 밸류로 jsp에서 작성했던 name 속성 값을 담으면 알아서 해당 매개변수로 받아올 수 있음
	 * 만약 넘어온 값이 비어있는 형태라면 defaultValue 속성으로 기본값을 지정할 수 있음
	 * 
	 * @RequestParam 생략 가능
	 */
	/*@RequestMapping("login.me")
	public String loginMember(@RequestParam(value="userId", defaultValue="ddd") String id, @RequestParam String userPwd) {
//		RequestParam은 생략 가능, 원래 그 안에서 찾아서 가져오는 것?
//		전달값과 받아주는 값이 다른 경우 value 안에 전달값 이름을 쓰면 매치 가능
//		빈 값으로 오는 게 싫으면 default 값 지정 가능
		System.out.println("userId : " + id);
		System.out.println("userPwd : " + userPwd);
//		보낸 키와 받는 키가 이름이 동일하면 그대로 매치 시켜서 값을 보내줌
		return "main";
		// == /WEB-INF/views/main.jsp
	}*/
	
	/*
	 * 3. 커맨드 객체 방식
	 * 
	 * 해당 메소드의 매개변수로 요청 시 전달값을 담고자 하는 vo 클래스의 타입을 세팅 후
	 * 요청 시 전달값의 키값(jsp의 name 속성값)을 vo 클래스에 담고자 하는 필드명으로 작성
	 */
	
	/*
	@RequestMapping("login.me")
	public String loginMember(Member m) {
//		Member 객체 안에 자동으로 세팅 되어서 들어옴
//		스프링 컨테이너에 이미 어노테이션이 있기 때문에 이 메소드 조회, 그 안의 객체 필드명과 일치하면 그냥 받아주는 것
//		게시글 수정 하거나 할 때 통으로 정보를 넘김 그럴 때 객체로 세팅해서 받아줄 수 있음
//		여기로 맵핑이 되었을 때 전달값 키와 객체 필드명이 일치하면 자동으로 넣어준다.
		System.out.println("userId : " + m.getUserId());
		System.out.println("userPwd : " + m.getUserPwd());
		
//		서비스로 넘겨줄 것
//		Member loginUser = new MemberServiceImpl(); 
//		이렇게 하면 유저가 만드는 거니까 의존성이 떨어짐, 바뀌면 유저가 수동으로 바꿔야 함
		
		Member loginUser = memberService.loginMember(m);
//		스프링이 알아서 객체를 생성해서 주려면 bean에 등록해야 함
//		직접 해줘도 되고 어노테이션을 이용해서 등록해도 됨
		
		if(loginUser == null) {
			System.out.println("로그인 실패");
		} else {
			System.out.println("로그인 성공");
		}
		
		return "main";
		// == /WEB-INF/views/main.jsp
	}*/
//	필터는 url 파라미터 쭉 나열해서 사용하면 된다?
	
	/*
	 * 요청 처리 후 응답 데이터를 담고 응답 페이지로 포워딩 또는 url 재요청 처리하는 방법
	 * 
	 * 1. 스프링에서 제공하는 Model 객체를 이용하는 방법
	 * - 포워딩한 응답뷰로 전달 하고자 하는 데이터를 맵 형식(k-v)으로 담을 수 있는 영역
	 * - Model 객체는 requestScope
	 * - request.setAttribute 이용 했었는데 이제는 model.addAttribute 이용
	 */
	
	/*
	@RequestMapping("login.me")
	public String loginMember(Member m, Model model, HttpSession session) {
		Member loginUser = memberService.loginMember(m);
//		HttpSession도 서블릿에서 request에서 꺼내서 만들어줄 수 있으므로 받아오면 됨
		
		if(loginUser == null) { // 로그인 실패 -> 에러 문구를 requestScope에 담고 에러 페이지로 포워딩
			model.addAttribute("errorMsg", "로그인 실패");
			return "/common/errorPage";
		} else { // 로그인 성공 -> sessionScope에 로그인 유저 담아서 메인으로 url 재요청
			// /WEB-INF/views/common/errorPage.jsp
			session.setAttribute("loginUser", loginUser);
			return "redirect:/";
//			redirect 요청은 이렇게 써줌 / 현재 페이지니까 이렇게 쓴 건가?
		}
	}*/
	
	// 2. 스프링에서 제공하는 ModelAndView 객체 사용
//	이건 잘 안 씀
	@RequestMapping("login.me")
	public ModelAndView loginMember(Member m, ModelAndView mv, HttpSession session) {
		Member loginUser = memberService.loginMember(m);
		
		if(loginUser == null) { // 로그인 실패 -> 에러 문구를 requestScope에 담고 에러 페이지로 포워딩
//			model.addAttribute("errorMsg", "로그인 실패");
			mv.addObject("errorMsg", "로그인 실패");
//			return "/common/errorPage";
			mv.setViewName("common/errorPage"); // 리턴과 똑같은 효과
		} else { // 로그인 성공 -> sessionScope에 로그인 유저 담아서 메인으로 url 재요청
			session.setAttribute("loginUser", loginUser);
			
//			return "redirect:/";
			mv.setViewName("redirect:/");
		}
		return mv;
	}
//	굳이 컨트롤러 다시 안 받아줘도 됨, 매핑값만 잘 해주면 됨
	@RequestMapping("logout.me")
	public String logoutMember(HttpSession session) {
		session.removeAttribute("loginUser");
		// session.invalidate(); -> 만료
		return "redirect:/";
	}
	
	@RequestMapping("enrollForm.me")
	public String enrollForm() {
		return "member/memberEnrollForm";
	}

	//	보내주는 name 값을 객체 필드랑 일치 시켜줘야 스프링이 받아올 때 바로 매치 시켜서 편하게 받아옴

	//
	@ResponseBody
	@RequestMapping("idCheck.me")
	public String idCheck(String checkId) {
		System.out.println(checkId);
		return "NNNNN"; // jsp 페이지로 포워딩 되는 경로로 만들어주게 됨 -> 데이터 전송한다는 걸 다시 알려줘야 함
	}
}
